---
title: "Plotting seahorse"
webr:
  packages: ['tidyverse']
editor: 
  mode: source  
---

Now, lets plot some Seahorse data. For this we need to import some here into this session. We use a dataset that was we published in Scientific Reports [Janssen et al.](https://www.nature.com/articles/s41598-021-81217-4). It is data from PBMCs where we followed OCR and ECAR using Extracellular Flux analysis with the XFe96 over time and during that time we injected after three measurement phases FCCP, and after six measurement phases we injected Antimycin/Rotenone (AM/Rot). The data is available from [github](https://github.com/vcjdeboer/seahtrue/tree/main/inst/extdata).

``` {webr-r}
library(tidyverse)

#set file source
root_srcfile <- 
  "https://raw.githubusercontent.com/vcjdeboer/seahtrue/main/"

#download file and rename to "VB.xlsx"
download.file(
  paste0(
    root_srcfile,
    "inst/extdata/20191219 SciRep PBMCs donor A.xlsx"), 
  "VB.xlsx")

#read xlsx file
xf<-readxl::read_xlsx("VB.xlsx", sheet = "Rate")

xf %>% glimpse()

```

As you can see from the `glimpse`, the data table that we have now (we call it a `tibble` in tidy lanuguage), contains 7 columns; `Measurement`, `Well`, `Group`, `Time`, `OCR`, `ECAR`, `PER`. The data is allready nice and tidyly organized in the Rate sheet of the excel file that we have loaded. The file was generated in the Wave Agilent software and directly comes from exporting the Seahorse data to xlsx.

I prefer to use lower case column names without any spaces, so for these column names we have to turn them into lower case first. We use some easy functions from the `janitor` package for this.

``` {webr-r}
webr::install("janitor")
xf %>% janitor::clean_names()

```

Next, we can start plotting data using ggplot. Let's introduce the `filter` command from `dplyr`. Whereas `select` is there to select columns, `filter` is there to select rows. So let's filter the rows for the group with is labeled "200.000" (200.000 cells/per well) and the "Background" group.

``` {webr-r}

xf %>% 
  janitor::clean_names() %>%
  filter(group %in% c("200.000", "Background")) %>% 
  glimpse()
  

```

::: {.callout-note collapse="true"}
## The filter command

Filtering data is selecting the rows based on some arguments. You need some to understand some semnatics here. For filtering based on multiple conditions we use `group %in% c("200.000", "Background")`, for filtering based on a single condition we can use `group == "200.000"`. The `%in%` operator is used to match two items. 

``` {r}

1 %in% c(1,2,3,4,5) #is TRUE

```

``` {r}
# just like
1 == 1 #is TRUE

```

``` {r}
#the reverse is also possible
c(1,2,3,4,5) %in% 1
#is TRUE FALSE FALSE FALSE FALSE FALSE

```

``` {webr-r}
#Try the 1 = 1 here as well

1 = 1

#the = operator is reserved for assignment
#just like the <- operator
# == is used for comparison
```

``` {webr-r}

#say that we have the following vector 
#( = groups in experiment)
group <- c("Background", "50.0000", 
           "100.000", "150.000",
           "200.000", "250.000", 
           "300.000")

#we can do the same without typing the
#names by hand like this:
group <- xf %>% 
          pull(Group) %>% 
          unique()

#then

c("200.000", "Background") %in% group

#generates TRUE TRUE

group %in% c("200.000", "Background")

#generates:
#TRUE FALSE FALSE FALSE TRUE FALSE FALSE

```

Thus the `group %in% c("200.000", "Background")` statement in the filter function above tells which group items to use. For `200.000` there is match (`TRUE`), but for `100.000` there is not a match (it is `FALSE`). 
:::

Now that we know how to filter we can use the filtered data to make the ggplot.

``` {webr-r}

xf %>% 
  janitor::clean_names() %>%
  filter(group %in% c("200.000", "Background")) %>% 
  ggplot(aes(x = time, y = ocr))+
  geom_point()
  

```

That plot is not so informative. Let's make it prettier. First, add lines:

``` {webr-r}

xf %>% 
  janitor::clean_names() %>%
  filter(group %in% c("200.000", "Background")) %>% 
  ggplot(aes(x = time, y = ocr,
  #the group command in aes is important for lines
  #ggplot wants to know how to connect dots
             group = well, 
             color = group))+
    geom_point()+
    geom_line()
  

```

Next, change colors:

``` {webr-r}

xf %>% 
  janitor::clean_names() %>%
  filter(group %in% c("200.000", "Background")) %>% 
  ggplot(aes(x = time, y = ocr,
             group = well, 
             color = group))+
    geom_point()+
    geom_line() +
    scale_color_brewer(palette = "Set1")
  

```

Change theme and text size:

``` {webr-r}

xf %>% 
  janitor::clean_names() %>%
  filter(group %in% c("200.000", "Background")) %>% 
  ggplot(aes(x = time, y = ocr,
             group = well, 
             color = group))+
    geom_point()+
    geom_line() +
    scale_color_brewer(palette = "Set1")+
    theme_bw(base_size = 16)
  
```

Add titles:

``` {webr-r}

xf %>% 
  janitor::clean_names() %>%
  filter(group %in% c("200.000", "Background")) %>% 
  ggplot(aes(x = time, y = ocr,
             group = well, 
             color = group))+
    geom_point()+
    geom_line() +
    scale_color_brewer(palette = "Set1")+
    labs(subtitle = "200.000 cells per well vs Background",
         x = "time (minutes)",
         y = "OCR (pmol/min)")+
    theme_bw(base_size = 16)
  
```

This is a very nice plot. It shows all OCR curve for each well for the `200.000` and the `background` groups. The information that is now not in the plot is which line matches to which well. 

Exercise
We can color each line (but there are too many wells so it will not be nice!). 
* Change this in the above code `color = well` instead of `color = group`. 
* You will notice that the there are not enough colors in the `brewer` palette `Set1`, so you go back to the default coloring by deleting the `scale_color_brewer` line as well. Use th `#` to comment out the line.
* Now notice that the legend is huge and not completely visible, againg indicating that this is not the way to go

Instead, we can try to label the lines. The `ggrepel` package is not yet available in webr, so for now we have to use the `geom_text` or `annotate` commands from `ggplot`. The benefit of `ggrepel` is that it automatically prevents text overlap.

``` {webr-r}



xf %>% 
  janitor::clean_names() %>%
  filter(group %in% c("200.000", "Background")) %>% 
  ggplot(aes(x = time, y = ocr,
             group = well, 
             color = group))+
     # here are the labels using geom_text
     geom_text(data = . %>%
                    filter(time == 
                              max(unique(time))) %>%
                    filter(ocr  == 
                              min(ocr)),
               aes(label = well),
               vjust = 2,
               hjust = 1)+
     geom_text(data = . %>%
                    filter(time <20 & time > 15) %>%
                    filter(ocr  == max(ocr)),
               aes(label = well),
               vjust = -0.3,
               hjust = 1)+
    geom_point()+
    geom_line() +
    scale_color_brewer(palette = "Set1")+
    labs(subtitle = "200.000 cells per well vs Background",
         x = "time (minutes)",
         y = "OCR (pmol/min)")+
    theme_bw(base_size = 16)
  
```

Although we now labeled lines that are at the minimum and maximum OCR, this is only usefull for this one plot in these conditions. The position of the label is tweaked based on this specific plot, making this not such a quick solution to our problem. 

We can also try to use the `ggiraph` package. This brings in some nice interactivity into the plot. Since we are now working with the plot in a browser, this can be very handy. Also if we want to publish the plot as html and not a plain PDF this can be usefull. `ggiraph` is unfortunately also not available for wasm/webr since one dependent package is not available `uuid`, and I also can't get it to run via quarto.....



